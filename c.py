import numpy as np
import scipy as scp
import matplotlib.pyplot as plt
from mpl_toolkits import mplot3d
from matplotlib import cm, ft2font
import math
from scipy import sparse
from scipy.sparse.linalg import splu
from scipy.sparse.linalg import spsolve
import sympy; sympy.init_printing()

class GeometricBrownianMotion:

    def simulate_paths(self):
        while(self.T - self.dt > 0):
            dWt = np.random.normal(0, math.sqrt(self.dt))  # Brownian motion
            dYt = self.r*self.dt + self.sig*dWt  # Change in price
            self.current_price += self.current_price * dYt  # Add the change to the current price
            self.prices.append(self.current_price)  # Append new price to series
            self.T -= self.dt  # Accound for the step in time

    def __init__(self, S0, r, sig, dt, T):
        self.current_price = S0
        self.S0 = S0
        self.r = r
        self.sig = sig
        self.dt = dt
        self.T = T
        self.prices = []
        self.simulate_paths()


class European_Call_Payoff:

    def __init__(self, strike):
        self.strike = strike

    def get_payoff(self, stock_price):
        return np.maximum(stock_price - self.strike, 0)



r = 0.1; sig = 0.2                
S0 = 100; X0 = np.log(S0)          
K = 100; Texpir = 1   
pathnum = 100; 
Nspace = 3000   # M space steps
Ntime = 2000    # N time steps   

ftn = European_Call_Payoff(S0)

S_max = 3*float(K)                
S_min = float(K)/3

x_max = np.log(S_max)  # A2
x_min = np.log(S_min)  # A1

x, dx = np.linspace(x_min, x_max, Nspace, retstep=True)   # space discretization
T, dt = np.linspace(0, Texpir, Ntime, retstep=True)       # time discretization

Payoff = ftn.get_payoff(np.exp(x))

V = np.zeros((Nspace,Ntime))       # grid initialization
offset = np.zeros(Nspace-2)        # vector to be used for the boundary terms   

V[:,-1] = Payoff                   # terminal conditions 
V[-1,:] = np.exp(x_max) - K * np.exp(-r* T[::-1] )  # boundary condition
V[0,:] = 0                         # boundary condition
# construction of the tri-diagonal matrix D
sig2 = sig*sig; dxx = dx * dx

a = ( (dt/2) * ( (r-0.5*sig2)/dx - sig2/dxx ) )
b = ( 1 + dt * ( sig2/dxx + r ) )
c = (-(dt/2) * ( (r-0.5*sig2)/dx + sig2/dxx ) )

D = sparse.diags([a, b, c], [-1, 0, 1], shape=(Nspace-2, Nspace-2)).tocsc()


# Backward iteration
for i in range(Ntime-2,-1,-1):
    offset[0] = a * V[0,i]
    offset[-1] = c * V[-1,i]; 
    V[1:-1,i] = spsolve( D, (V[1:-1,i+1] - offset) )   

# finds the option at S0
oPrice = np.interp(X0, x, V[:,0])



dt = 1/365
price_paths = []

# Generate a set of sample paths
for i in range(0, pathnum):
    price_paths.append(GeometricBrownianMotion(S0, r, sig, dt, Texpir).prices)


MC_V = []
for initial in np.exp(x):
    call_payoffs = []
    for price_path in price_paths:
        call_payoffs.append(ftn.get_payoff(price_path[-1] *initial/S0 )/(1+r))  # We get the last stock price in the series generated by GBM to determin the payoff and discount it by one year
    MC_V.append(np.average(call_payoffs))



S = np.exp(x)
fig = plt.figure(figsize=(15,6))
ax1 = fig.add_subplot(121)
ax2 = fig.add_subplot(122, projection='3d')

ax1.plot(S, Payoff, color='blue',label="Payoff")
ax1.plot(S, V[:,0], color='red',label="BS curve")
ax1.plot(S, MC_V, color = 'green', label = "Monte Carlo")
ax1.set_xlim(60,170); ax1.set_ylim(0,50)
ax1.set_xlabel("S"); ax1.set_ylabel("price")
ax1.legend(loc='upper left'); ax1.set_title("price at t=0")

X, Y = np.meshgrid(T, S)
ax2.plot_surface(Y, X, V, cmap=cm.ocean)
ax2.set_title("BS price surface")
ax2.set_xlabel("S"); ax2.set_ylabel("t"); ax2.set_zlabel("V")
ax2.view_init(30, -100) # this function rotates the 3d plot
plt.show()
